import React, { useState, useEffect, useCallback, useMemo, useRef, memo } from 'react';
import styled from 'styled-components';
import { motion } from 'framer-motion';
import { useNavigate, useLocation, useSearchParams } from 'react-router-dom';
import LineChart from '../components/LineChart';
import BubbleChart from '../components/BubbleChart';
import ReportingControls from '../components/ReportingControls';
import { standardizedMetrics, CURRENT_KEY_METRICS } from '../data/companyData';
import { useTooltip } from '../components/GlobalTooltip';
import MerchantSegmentation from '../components/MerchantSegmentation';
import BarChart from '../components/BarChart';

// Constants for consistent styling
const STRIPE_PURPLE = '#635bff';
const STRIPE_PURPLE_LIGHT = 'rgba(99, 91, 255, 0.1)';
const GRAY = '#aab7c4';
const USAGE_BLUE = '#469FBF';
const TREND_POSITIVE = '#217005';
const TREND_NEGATIVE = '#B13600';

const PageContainer = styled(motion.div)`
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 24px;
`;

const HeaderContainer = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
`;

const Title = styled.h1`
  font-family: -apple-system, "system-ui", "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 28px;
  font-synthesis-weight: none;
  font-weight: 700;
  height: 36px;
  line-height: 36px;
  margin: 0;
`;

const EditLayoutButton = styled.button`
  padding: 8px 12px;
  background-color: white;
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  
  &:hover {
    background-color: rgba(0, 0, 0, 0.04);
  }
  
  svg {
    width: 16px;
    height: 16px;
  }
`;

const TabsContainer = styled.div`
  display: flex;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 24px;
`;

const Tab = styled.button`
  background: none;
  border: none;
  padding: 12px 16px;
  font-size: 15px;
  font-weight: ${props => props.active ? '600' : '400'};
  color: ${props => props.active ? STRIPE_PURPLE : 'var(--text-color)'};
  border-bottom: 2px solid ${props => props.active ? STRIPE_PURPLE : 'transparent'};
  cursor: pointer;
  margin-right: 8px;
  transition: all 0.2s ease;
  
  &:hover {
    color: ${STRIPE_PURPLE};
  }
`;

const ControlsContainer = styled.div`
  margin-bottom: 32px;
`;

const ControlsRow = styled.div`
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
`;

const ControlButton = styled.button`
  padding: 8px 16px;
  background-color: ${props => props.active ? STRIPE_PURPLE : 'white'};
  color: ${props => props.active ? 'white' : 'var(--text-secondary)'};
  border: 1px solid ${props => props.active ? STRIPE_PURPLE : 'var(--border-color)'};
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  
  &:hover {
    background-color: ${props => props.active ? STRIPE_PURPLE : 'rgba(0, 0, 0, 0.04)'};
  }
`;

const ControlLabel = styled.div`
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 6px;
`;

const ControlGroup = styled.div`
  display: flex;
  flex-direction: column;
`;

const ButtonGroup = styled.div`
  display: flex;
  
  button {
    border-radius: 0;
    
    &:first-child {
      border-top-left-radius: 6px;
      border-bottom-left-radius: 6px;
    }
    
    &:last-child {
      border-top-right-radius: 6px;
      border-bottom-right-radius: 6px;
    }
    
    &:not(:last-child) {
      border-right: none;
    }
  }
`;

const ComparisonSelect = styled.select`
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  background-color: white;
  font-size: 14px;
`;

const MetricsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin-bottom: 30px;
`;

const MetricCard = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  position: relative;
  cursor: pointer;
  
  &:hover {
    .explore-action {
      opacity: 1;
    }
  }
`;

const MetricHeader = styled.div`
  display: flex;
  flex-direction: column;
  margin-bottom: 8px;
`;

const MetricTitle = styled.h3`
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  margin: 0 0 4px 0;
`;

const MetricValueRow = styled.div`
  display: flex;
  align-items: center;
  margin-bottom: 4px;
`;

const MetricValue = styled.div`
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 4px;
  display: flex;
  align-items: center;
`;

const MetricTrend = styled.div`
  display: flex;
  align-items: center;
  font-size: 14px;
  color: ${props => props.trend === 'up' ? TREND_POSITIVE : TREND_NEGATIVE};
  white-space: nowrap;
  font-weight: 500;
  margin-left: 8px;
`;

const MetricChartContainer = styled.div`
  flex-grow: 1;
  min-height: 160px;
  margin-top: auto;
  margin-bottom: 8px;
  position: relative;
`;

const Tooltip = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  opacity: 0;
  background-color: white;
  color: #333;
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  transform: translate(-50%, -100%);
  transition: opacity 0.2s ease;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  border: 1px solid #e3e8ee;
  font-weight: 500;
  
  &.visible {
    opacity: 1;
  }
  
  &:after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: white transparent transparent transparent;
  }
  
  strong {
    color: ${STRIPE_PURPLE};
    font-weight: 600;
    display: block;
    margin-bottom: 4px;
  }
  
  .current-value {
    color: ${TREND_POSITIVE};
    font-weight: 500;
  }
  
  .previous-value {
    color: ${GRAY};
    margin-top: 2px;
  }
`;

const TabTitle = styled.h2`
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 20px;
  color: #1a1f36;
`;

const ReportSection = styled.div`
  margin-top: 40px;
`;

const ReportCard = styled.div`
  margin-bottom: 24px;
  padding-bottom: 24px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
  
  &:last-child {
    border-bottom: none;
  }
`;

const ReportInfo = styled.div`
  flex: 1;
`;

const ReportTitle = styled.h3`
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 4px;
`;

const ReportDescription = styled.p`
  font-size: 14px;
  color: var(--text-secondary);
  margin-bottom: 12px;
`;

const DownloadButton = styled.button`
  padding: 8px 16px;
  background-color: white;
  color: ${STRIPE_PURPLE};
  border: 1px solid ${STRIPE_PURPLE};
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
  
  &:hover {
    background-color: ${STRIPE_PURPLE_LIGHT};
  }
  
  svg {
    width: 16px;
    height: 16px;
  }
`;

const SectionTitle = styled.h2`
  font-size: 16px;
  font-weight: 700;
  margin: 0 0 16px 0;
`;

const EmptySection = styled.div`
  background: white;
  border-radius: 8px;
  padding: 24px;
  margin-bottom: 32px;
  min-height: 150px;
`;

const TrendingGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 32px;
`;

const TrendingCard = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  cursor: pointer;
  position: relative;
  transition: box-shadow 0.2s ease, transform 0.2s ease;
  display: flex;
  flex-direction: column;
  
  &:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    transform: translateY(-2px);
    
    .explore-action {
      opacity: 1;
    }
  }
`;

const TrendingTitle = styled.div`
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 8px;
  color: var(--text-secondary);
`;

const TrendingContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const TrendingValueSection = styled.div`
  display: flex;
  flex-direction: column;
`;

const TrendingValue = styled.div`
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 4px;
`;

const TrendingTrend = styled.span`
  font-size: 14px;
  font-weight: 500;
  color: ${props => props.trend === 'up' ? TREND_POSITIVE : TREND_NEGATIVE};
`;

const SparklineContainer = styled.div`
  height: 50px;
  width: 100px;
  margin-left: 8px;
`;

const ExploreAction = styled.div`
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  color: ${STRIPE_PURPLE};
  font-size: 13px;
  font-weight: 500;
  opacity: 0;
  transition: opacity 0.2s ease;
  
  svg {
    margin-left: 4px;
  }
`;

// Add report definitions before the component definition
const summaryReports = [
  { id: 'mrr-report', title: 'MRR Report' },
  { id: 'revenue-summary', title: 'Revenue Summary' },
  { id: 'annual-projections', title: 'Annual Projections' }
];

const revenueReports = [
  { id: 'mrr-breakdown', title: 'MRR Breakdown' },
  { id: 'revenue-by-plan', title: 'Revenue by Plan' },
  { id: 'revenue-growth', title: 'Revenue Growth Analysis' }
];

const subscriberReports = [
  { id: 'subscriber-acquisition', title: 'Subscriber Acquisition Report' },
  { id: 'customer-lifetime-value', title: 'Customer Lifetime Value' },
  { id: 'subscriber-segments', title: 'Subscriber Segments' }
];

const invoiceReports = [
  { id: 'invoice-payments-summary', title: 'Invoice Payments Summary' },
  { id: 'past-due-invoices', title: 'Past Due Invoices' },
  { id: 'payment-methods', title: 'Payment Methods Analysis' }
];

const usageReports = [
  { id: 'usage-breakdown', title: 'Usage Breakdown by Product' },
  { id: 'usage-trends', title: 'Usage Trends' }
];

const churnReports = [
  { id: 'churn-reasons', title: 'Churn Reasons Analysis' },
  { id: 'churn-prevention', title: 'Churn Prevention Opportunities' },
  { id: 'win-back-campaigns', title: 'Win-back Campaign Results' }
];

const trialReports = [
  { id: 'trial-conversion-funnel', title: 'Trial Conversion Funnel' },
  { id: 'trial-usage-patterns', title: 'Trial Usage Patterns' }
];

const ReportsSection = styled.div`
  margin-top: 30px;
  background: white;
  border-radius: 8px;
  padding: 20px;
`;

const ReportButtonsContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
`;

const ReportButton = styled.button`
  display: flex;
  align-items: center;
  padding: 8px 16px;
  background-color: #f7fafc;
  border: 1px solid #e3e8ee;
  border-radius: 4px;
  font-size: 14px;
  color: #425466;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    background-color: #f0f4f8;
    border-color: #d6dce7;
  }
`;

const DownloadIcon = styled.span`
  display: inline-flex;
  margin-right: 8px;
  color: #6772e5;
`;

// Modify the MetricChart component to better handle tooltips
const MetricChart = memo(({
  metric, 
  activePeriod, 
  interval, 
  comparison, 
  generateMetricChartData,
  handleShowTooltip,
  hideTooltip
}) => {
  // Refs for optimized tooltip handling
  const throttleRef = useRef(null);
  
  // Memoized event handlers to prevent recreating on each render
  const chartData = useMemo(() => {
    return generateMetricChartData(metric, activePeriod, interval, comparison !== 'none');
  }, [metric, activePeriod, interval, comparison, generateMetricChartData]);
  
  const optimizedTooltipHandler = useCallback((e) => {
    if (!e || !e.currentTarget) return;
    if (throttleRef.current) return;
    
    throttleRef.current = setTimeout(() => {
      throttleRef.current = null;
    }, 100);
    
    handleShowTooltip(e, metric.id, chartData);
  }, [metric.id, chartData, handleShowTooltip]);
  
  const optimizedHideTooltip = useCallback(() => {
    hideTooltip();
  }, [hideTooltip]);

  // Only render if we have valid chart data
  if (!chartData || !chartData.labels || !chartData.datasets) {
    return <div>No data available</div>;
  }
  
  return (
    <MetricChartContainer 
      onMouseMove={optimizedTooltipHandler}
      onMouseLeave={optimizedHideTooltip}
    >
      <LineChart 
        data={chartData} 
        height={160}
        showLegend={false}
        unit={metric.unit || 'currency'}
      />
    </MetricChartContainer>
  );
}, (prevProps, nextProps) => {
  // Optimize re-renders with more comprehensive checks
  return (
    prevProps.metric.id === nextProps.metric.id &&
    prevProps.activePeriod === nextProps.activePeriod &&
    prevProps.interval === nextProps.interval &&
    prevProps.comparison === nextProps.comparison
  );
});

const TwoColumnLayout = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 32px;
`;

const MetricColumnCard = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: none;
  cursor: pointer;
  transition: box-shadow 0.2s ease, transform 0.2s ease;
  
  &:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    transform: translateY(-2px);
    
    .explore-action {
      opacity: 1;
    }
  }
`;

const PlaceholderContainer = styled.div`
  background: #f7f7f7;
  border-radius: 8px;
  min-height: 180px;
`;

const ForecastingContainer = styled.div`
  border-radius: 8px;
  padding: 20px;
  height: 100%;
  min-height: 240px;
  display: flex;
  flex-direction: column;
  background-color: white;
  justify-content: space-between;
`;

const ForecastingHeading = styled.h4`
  font-size: 14px;
  font-weight: 600;
  color: #1a1f36;
  margin: 0 0 16px 0;
`;

const ToggleContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: flex-start;
  margin-bottom: 12px;
`;

const ToggleLabel = styled.span`
  font-size: 14px;
  color: var(--text-color);
  margin-left: 12px;
`;

const ToggleSwitch = styled.label`
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
  
  input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  span {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .3s;
    border-radius: 20px;
    
    &:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
    }
  }
  
  input:checked + span {
    background-color: ${STRIPE_PURPLE};
  }
  
  input:checked + span:before {
    transform: translateX(20px);
  }
`;

const InsightContainer = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  height: 100%;
  min-height: 180px;
  display: flex;
  flex-direction: column;
`;

const InsightHeading = styled.h4`
  font-size: 14px;
  font-weight: 600;
  color: #1a1f36;
  margin: 0 0 6px 0;
`;

const InsightText = styled.p`
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-color);
  margin: 0 0 8px 0;
`;

const RecommendationHeader = styled.div`
  display: flex;
  align-items: center;
  cursor: pointer;
  margin: 16px 0 12px 0;
`;

const ChevronIcon = styled.span`
  margin-left: 6px;
  transition: transform 0.3s ease;
  transform: ${props => props.expanded ? 'rotate(90deg)' : 'rotate(0deg)'};
`;

const RecommendationContent = styled.div`
  max-height: ${props => props.expanded ? '500px' : '0'};
  overflow: hidden;
  transition: max-height 0.3s ease;
`;

const MailchimpButton = styled.button`
  background-color: white;
  color: ${STRIPE_PURPLE};
  border: 1px solid ${STRIPE_PURPLE};
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-top: 8px;
  width: auto;
  align-self: flex-start;
  
  &:hover {
    background-color: ${STRIPE_PURPLE_LIGHT};
  }
  
  &:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(99, 91, 255, 0.3);
  }
`;

// Create a non-interactive styled card specifically for the Total Revenue chart
const StaticMetricCard = styled.div`
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  position: relative;
  cursor: default;
`;
              <p style={{ fontSize: '13px', color: '#6B7C93', margin: 0, lineHeight: '1.4' }}>
                Adjust these inputs to see how different revenue sources affect your forecast for the next month.
              </p>
            </div>
          </ForecastingContainer>
        );
      };
      
      return (
        <>
          <div>
            <SectionTitle>Trending</SectionTitle>
            <TrendingGrid>
              {trendingMetrics.map(metric => (
                <TrendingCard key={metric.id} onClick={() => handleMetricClick(metric)}>
                  <ExploreAction className="explore-action">
                    Explore
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M7 17L17 7" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                      <path d="M7 7H17V17" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                    </svg>
                  </ExploreAction>
                  
                  <TrendingTitle>{metric.title}</TrendingTitle>
                  <TrendingContent>
                    <TrendingValueSection>
                      <TrendingValue>{metric.displayValue}</TrendingValue>
                      <TrendingTrend trend={metric.trend}>{metric.trendDisplay}</TrendingTrend>
                    </TrendingValueSection>
                    <SparklineContainer>
                      <LineChart 
                        data={metric.chartData} 
                        height={50} 
                        showLegend={false} 
                        showAxes={false}
                        unit={metric.unit}
                        reducedLabels={true}
                      />
                    </SparklineContainer>
                  </TrendingContent>
                </TrendingCard>
              ))}
            </TrendingGrid>
          </div>
          
          <div>
            <SectionTitle>Subscriber adoption</SectionTitle>
            <MetricsGrid>
              {renderSimpleMetric(stableNewSubscribersData)}
              <InsightModule />
            </MetricsGrid>
          </div>
          
          <div>
            <SectionTitle>Forecasting revenue</SectionTitle>
            <MetricsGrid>
              {renderBarChartMetricWithLegend(modifiedTotalRevenueData)}
              <ConnectedForecastingInputs />
            </MetricsGrid>
          </div>
          
          <div style={{ marginTop: '32px' }}>
            <SectionTitle>Merchant Distribution</SectionTitle>
            <MerchantSegmentation />
          </div>
        </>
      );
      
    default:
      return (
        <div style={{ textAlign: 'center', padding: '40px 0' }}>
          <p>Select a tab to view content.</p>
        </div>
      );
  }
};

// Helper function to render reports - restored previous treatment
const renderReportSection = (title, reports) => {
  return (
    <ReportSection>
      <SectionTitle>{title}</SectionTitle>
      
      {reports.map(report => (
        <ReportCard key={report.id || report.title}>
          <ReportInfo>
            <ReportTitle>{report.title}</ReportTitle>
            <ReportDescription>{report.description}</ReportDescription>
          </ReportInfo>
          <DownloadButton onClick={() => handleReportDownload(report)}>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M21 15V19C21 19.5304 20.7893 20.0391 20.4142 20.4142C20.0391 20.7893 19.5304 21 19 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V15" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              <path d="M7 10L12 15L17 10" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              <path d="M12 15V3" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
            </svg>
            Download
          </DownloadButton>
        </ReportCard>
      ))}
    </ReportSection>
  );
};

// Function to handle report download
const handleReportDownload = (report) => {
  console.log(`Downloading report: ${report.title}`);
  // In a real implementation, this would trigger an API call or generate a report
  // toast.success(`Started download: ${report.title}`);
};

// Fix the renderMetricsGrid function to not multiply percentages by 100
const renderMetricsGrid = (metrics, gridType = 'default') => {
  return (
    <MetricsGrid type={gridType}>
      {metrics.map(metric => {
        const valueDisplay = metric.isCurrency 
          ? formatCurrency(metric.baseCurrencyValue)
          : metric.unit === 'percentage'
            ? formatPercentage(metric.baseNumberValue)
            : metric.unit === 'days'
              ? `${formatNumber(metric.baseNumberValue)} ${metric.baseNumberValue === 1 ? 'day' : 'days'}`
              : formatNumber(metric.baseNumberValue);
              
        const trendDisplay = metric.unit === 'days'
          ? `${metric.trendValue} ${Math.abs(metric.trendValue) === 1 ? 'day' : 'days'} ${metric.trend === 'up' ? 'up' : 'down'}`
          : `${metric.trend === 'up' ? '+' : '-'}${Math.abs(metric.trendValue).toFixed(2)}%`;

        return (
          <MetricCard key={metric.id} onClick={() => handleMetricClick(metric)}>
            <ExploreAction className="explore-action">
              Explore
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 17L17 7" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                <path d="M7 7H17V17" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              </svg>
            </ExploreAction>
            
            <MetricHeader>
              <MetricTitle>{metric.title}</MetricTitle>
              <MetricValueRow>
                <MetricValue>
                  {valueDisplay}
                  {metric.trendValue > 0 && (
                    <MetricTrend trend={metric.trend}>
                      {trendDisplay}
                    </MetricTrend>
                  )}
                </MetricValue>
              </MetricValueRow>
            </MetricHeader>
            
            <MetricChart 
              metric={metric}
              activePeriod={activePeriod}
              interval={activeInterval}
              comparison={activeComparison}
              handleShowTooltip={handleShowTooltip}
              hideTooltip={hideTooltip}
              generateMetricChartData={generateMetricChartData}
            />
          </MetricCard>
        );
      })}
    </MetricsGrid>
  );
};

// Create a separate component for the insight module with its own state
const InsightModule = () => {
  return (
    <InsightContainer>
      <InsightHeading>Insight</InsightHeading>
      <InsightText>
        New subscriber growth is accelerating, largely driven by the recent launch of the Starter tier, which has lowered the barrier to entry. However, there's a noticeable uptick in users failing to complete onboarding, signaling a potential churn risk.
      </InsightText>
      
      <InsightHeading style={{ margin: '8px 0 6px 0' }}>Recommendation</InsightHeading>
      
      <InsightText>
        Review the Starter tier onboarding flow to identify friction points and consider targeted interventions—such as guided setup or email nudges—to improve early engagement and retention.
      </InsightText>
      
      <MailchimpButton>
        Set up automatic email workflow →
      </MailchimpButton>
    </InsightContainer>
  );
};

// Create a separate component for the forecasting inputs
const ForecastingInputs = () => {
  const [creditsEnabled, setCreditsEnabled] = useState(false);
  const [discountsEnabled, setDiscountsEnabled] = useState(true);
  
  return (
    <ForecastingContainer>
      <ForecastingHeading>Revenue composition</ForecastingHeading>
      
      <div style={{ marginTop: '20px' }}>
        <ToggleContainer>
          <ToggleSwitch>
            <input 
              type="checkbox" 
              checked={creditsEnabled}
              onChange={(e) => setCreditsEnabled(e.target.checked)}
            />
            <span />
          </ToggleSwitch>
          <ToggleLabel>Include credits</ToggleLabel>
        </ToggleContainer>
        
        <ToggleContainer style={{ marginTop: '16px' }}>
          <ToggleSwitch>
            <input 
              type="checkbox" 
              checked={discountsEnabled}
              onChange={(e) => setDiscountsEnabled(e.target.checked)}
            />
            <span />
          </ToggleSwitch>
          <ToggleLabel>Include discounts</ToggleLabel>
        </ToggleContainer>
      </div>
      
      <div style={{ marginTop: 'auto', paddingTop: '24px' }}>
        <p style={{ fontSize: '13px', color: '#6B7C93', margin: 0, lineHeight: '1.4' }}>
          Adjust these inputs to see how different revenue sources affect your forecast for the next month.
        </p>
      </div>
    </ForecastingContainer>
  );
};

// State for revenue composition (formerly forecasting) toggles
const [revenueComposition, setRevenueComposition] = useState({
  creditsEnabled: true,
  discountsEnabled: true
});

// Add placeholder variables for activityData and monthLabels
// These would typically come from a data source or API
const activityData = useMemo(() => ({
  revenue: [42000, 45000, 48000, 47000, 49000, 52000],
  revenueMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']
}), []);

const monthLabels = useMemo(() => ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'], []);

// Generate total revenue data
const totalRevenueData = useMemo(() => {
  if (!activityData || !activityData.revenue) return null;

  const baseData = {
    labels: activityData.revenueMonths || monthLabels,
    datasets: [
      {
        label: 'Total Revenue',
        data: [...activityData.revenue], // Create a copy of the array
        borderColor: STRIPE_PURPLE,
        fill: false,
        tension: 0.4
      }
    ]
  };

  return baseData;
}, [activityData, monthLabels]);

// Apply modifications based on revenue composition toggles
const modifiedRevenueData = useMemo(() => {
  if (!totalRevenueData) return null;

  // Create a deep clone of the data structure to avoid mutations
  const modifiedData = JSON.parse(JSON.stringify(totalRevenueData));
  
  // Base multipliers - these values will create visible but not dramatic changes
  const creditMultiplier = 1.12; // 12% increase with credits
  const discountMultiplier = 1.08; // 8% increase with discounts
  
  // Get the multiplier based on enabled features
  let multiplier = 1.0;
  
  if (revenueComposition.creditsEnabled) {
    multiplier *= creditMultiplier;
  }
  
  if (revenueComposition.discountsEnabled) {
    multiplier *= discountMultiplier;
  }
  
  // Apply the multiplier to the forecast part of the data (future months)
  const currentMonth = new Date().getMonth();
  
  modifiedData.datasets[0].data = modifiedData.datasets[0].data.map((value, index) => {
    // Only modify future months (forecasted data)
    if (index > currentMonth) {
      return value * multiplier;
    }
    return value;
  });
  
  return modifiedData;
}, [totalRevenueData, revenueComposition]);

// Calculate total forecasted revenue for display
const totalForecastedRevenue = useMemo(() => {
  if (!modifiedRevenueData || !modifiedRevenueData.datasets[0].data) return 0;
  
  const currentMonth = new Date().getMonth();
  const futureMonths = modifiedRevenueData.datasets[0].data.slice(currentMonth);
  
  return futureMonths.reduce((sum, value) => sum + value, 0);
}, [modifiedRevenueData]);
  
// Revenue composition (formerly forecasting inputs) component
const ConnectedRevenueComposition = () => {
  return (
    <ForecastToggleSection>
      <ForecastTitle style={{ marginBottom: '12px' }}>Revenue composition</ForecastTitle>
      
      <ForecastToggleContainer>
        <ForecastToggleSwitch>
          <input
            type="checkbox"
            checked={revenueComposition.creditsEnabled}
            onChange={() => setRevenueComposition(prev => ({
              ...prev,
              creditsEnabled: !prev.creditsEnabled
            }))}
          />
          <span></span>
        </ForecastToggleSwitch>
        <ForecastToggleLabel>Include credits</ForecastToggleLabel>
      </ForecastToggleContainer>
      
      <ForecastToggleContainer>
        <ForecastToggleSwitch>
          <input
            type="checkbox"
            checked={revenueComposition.discountsEnabled}
            onChange={() => setRevenueComposition(prev => ({
              ...prev,
              discountsEnabled: !prev.discountsEnabled
            }))}
          />
          <span></span>
        </ForecastToggleSwitch>
        <ForecastToggleLabel>Include discounts</ForecastToggleLabel>
      </ForecastToggleContainer>
      
      <HelperText>
        Adjust these settings to see how different revenue sources affect your projected revenue.
        Credits add about 12% to forecasted revenue, while discounts add 8%.
      </HelperText>
    </ForecastToggleSection>
  );
};

const BillingOverview = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const [searchParams] = useSearchParams();
  const [activeTab, setActiveTab] = useState('summary');
  const [activePeriod, setActivePeriod] = useState('last_3_months');
  const [activeInterval, setActiveInterval] = useState('daily');
  const [activeComparison, setActiveComparison] = useState('previous_period');
  const [tooltipState, setTooltipState] = useState({
    visible: false,
    x: 0,
    y: 0,
    content: '',
    metricId: ''
  });
  const [metricData, setMetricData] = useState([]);
  const { showTooltip, hideTooltip } = useTooltip();
  const [trendingMetrics, setTrendingMetrics] = useState([]);
  // State for revenue composition (formerly forecasting) toggles
  const [revenueComposition, setRevenueComposition] = useState({
    creditsEnabled: true,
    discountsEnabled: true
  });
  
  // Add placeholder variables for activityData and monthLabels
  // These would typically come from a data source or API
  const activityData = useMemo(() => ({
    revenue: [42000, 45000, 48000, 47000, 49000, 52000],
    revenueMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']
  }), []);
  
  const monthLabels = useMemo(() => ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'], []);

  // Use memoized values from standardized metrics for each tab section
  const baseRevenueMetrics = useMemo(() => [
    standardizedMetrics['mrr'],
    standardizedMetrics['mrr-growth'],
    standardizedMetrics['net-volume'],
    standardizedMetrics['mrr-growth-rate']
  ], []);

  const baseSubscribersMetrics = useMemo(() => [
    standardizedMetrics['active-subscribers'],
    standardizedMetrics['active-subscribers-growth'],
    standardizedMetrics['new-subscribers'],
    standardizedMetrics['churned-subscribers'],
    standardizedMetrics['arpu'],
    standardizedMetrics['subscriber-ltv']
  ], []);

  const baseInvoicesMetrics = useMemo(() => [
    standardizedMetrics['invoice-revenue'],
    standardizedMetrics['past-due-invoice-volume'],
    standardizedMetrics['avg-invoice-payment-length']
  ], []);

  const baseUsageMetrics = useMemo(() => [
    standardizedMetrics['usage-revenue'],
    standardizedMetrics['usage-count']
  ], []);

  const baseChurnMetrics = useMemo(() => [
    standardizedMetrics['subscriber-churn-rate'],
    standardizedMetrics['churned-revenue'],
    standardizedMetrics['gross-mrr-churn-rate'],
    standardizedMetrics['net-mrr-churn-rate']
  ], []);

  const baseTrialsMetrics = useMemo(() => [
    standardizedMetrics['new-trials'],
    standardizedMetrics['trial-conversion-rate'],
    standardizedMetrics['active-trials'],
    standardizedMetrics['converted-trials']
  ], []);
  
  // Generate total revenue data
  const totalRevenueData = useMemo(() => {
    if (!activityData || !activityData.revenue) return null;

    const baseData = {
      labels: activityData.revenueMonths || monthLabels,
      datasets: [
        {
          label: 'Total Revenue',
          data: [...activityData.revenue], // Create a copy of the array
          borderColor: STRIPE_PURPLE,
          fill: false,
          tension: 0.4
        }
      ]
    };

    return baseData;
  }, [activityData, monthLabels]);

  // Apply modifications based on revenue composition toggles
  const modifiedRevenueData = useMemo(() => {
    if (!totalRevenueData) return null;

    // Create a deep clone of the data structure to avoid mutations
    const modifiedData = JSON.parse(JSON.stringify(totalRevenueData));
    
    // Base multipliers - these values will create visible but not dramatic changes
    const creditMultiplier = 1.12; // 12% increase with credits
    const discountMultiplier = 1.08; // 8% increase with discounts
    
    // Get the multiplier based on enabled features
    let multiplier = 1.0;
    
    if (revenueComposition.creditsEnabled) {
      multiplier *= creditMultiplier;
    }
    
    if (revenueComposition.discountsEnabled) {
      multiplier *= discountMultiplier;
    }
    
    // Apply the multiplier to the forecast part of the data (future months)
    const currentMonth = new Date().getMonth();
    
    modifiedData.datasets[0].data = modifiedData.datasets[0].data.map((value, index) => {
      // Only modify future months (forecasted data)
      if (index > currentMonth) {
        return value * multiplier;
      }
      return value;
    });
    
    return modifiedData;
  }, [totalRevenueData, revenueComposition]);

  // Calculate total forecasted revenue for display
  const totalForecastedRevenue = useMemo(() => {
    if (!modifiedRevenueData || !modifiedRevenueData.datasets[0].data) return 0;
    
    const currentMonth = new Date().getMonth();
    const futureMonths = modifiedRevenueData.datasets[0].data.slice(currentMonth);
    
    return futureMonths.reduce((sum, value) => sum + value, 0);
  }, [modifiedRevenueData]);
  
  // Check for tab parameter in URL on component mount or when URL changes
  useEffect(() => {
    const tabParam = searchParams.get('tab');
    
    if (tabParam && ['summary', 'revenue', 'subscribers', 'invoices', 'usage', 'churn', 'trials'].includes(tabParam)) {
      setActiveTab(tabParam);
    }
  }, [searchParams]);
  
  // Update metrics data when period or interval changes
  useEffect(() => {
    try {
      // Generate updated metrics with chart data based on current active tab
      let metrics = [];
      
      switch (activeTab) {
        case 'revenue':
          metrics = baseRevenueMetrics;
          break;
        case 'subscribers':
          metrics = baseSubscribersMetrics;
          break;
        case 'invoices':
          metrics = baseInvoicesMetrics;
          break;
        case 'usage':
          metrics = baseUsageMetrics;
          break;
        case 'churn':
          metrics = baseChurnMetrics;
          break;
        case 'trials':
          metrics = baseTrialsMetrics;
          break;
        default:
          metrics = baseRevenueMetrics;
      }
      
      // Generate chart data for each metric
      const updatedMetrics = metrics.map(metric => {
        // Generate chart data for the metric
        const chartData = generateMetricChartData(metric, activePeriod, activeInterval, activeComparison !== 'no-comparison');
        
        // Format the display value
        const displayValue = metric.isCurrency
          ? formatCurrency(metric.baseCurrencyValue)
          : metric.unit === 'percentage'
            ? formatPercentage(metric.baseNumberValue)
            : formatNumber(metric.baseNumberValue);
        
        return {
          ...metric,
          value: displayValue,
          numericalValue: metric.isCurrency ? metric.baseCurrencyValue : metric.baseNumberValue,
          chartData: chartData
        };
      });
      
      setMetricData(updatedMetrics);
    } catch (error) {
      console.error("Error updating metrics data:", error);
    }
  }, [
    activePeriod, 
    activeInterval, 
    activeComparison, 
    activeTab, 
    baseRevenueMetrics, 
    baseSubscribersMetrics, 
    baseInvoicesMetrics, 
    baseUsageMetrics, 
    baseChurnMetrics, 
    baseTrialsMetrics, 
    generateMetricChartData, 
    formatCurrency, 
    formatPercentage, 
    formatNumber
  ]);
  
  // Format functions wrapped in useCallback to prevent recreation on each render
  const formatCurrency = useCallback((value) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(value);
  }, []);

  const formatPercentage = useCallback((value) => {
    return value.toFixed(2) + '%';
  }, []);

  const formatNumber = useCallback((value) => {
    return new Intl.NumberFormat('en-US').format(Math.round(value));
  }, []);

  // Handle metric card click
  const handleMetricClick = useCallback((metric) => {
    const metricId = metric.id;
    
    navigate(`/metrics/${metricId}`, { 
      state: { 
        metric: metric, 
        sourcePage: 'Billing',
        sourceTab: activeTab 
      } 
    });
  }, [navigate, activeTab]);

  // Define handleShowTooltip before it's used by other functions
  const handleShowTooltip = useCallback((event, metricId, chartData) => {
    // Skip processing if we don't have valid chart data
    if (!chartData || !chartData.labels || !chartData.datasets || !chartData.datasets.length) {
      return;
    }

    // Static ref for throttling that won't cause re-renders
    if (!event.currentTarget) return;
    
    // Use a more aggressive throttle to prevent flickering
    if (event.currentTarget._tooltipThrottleTimestamp && 
        Date.now() - event.currentTarget._tooltipThrottleTimestamp < 100) {
      return;
    }
    
    // Update timestamp instead of using a timeout
    event.currentTarget._tooltipThrottleTimestamp = Date.now();
    
    const chartRect = event.currentTarget.getBoundingClientRect();
    const xPosition = event.clientX - chartRect.left;
    const yPosition = event.clientY;
    const xRatio = xPosition / chartRect.width;
    const dataIndex = Math.floor(xRatio * chartData.labels.length);
    
    if (dataIndex < 0 || dataIndex >= chartData.labels.length) {
      return;
    }
    
    // For Total Revenue or other custom metrics, use the metric directly from standardizedMetrics or create a temporary one
    let metric;
    if (metricId === 'total-revenue') {
      metric = {
        id: 'total-revenue',
        title: 'Total revenue',
        isCurrency: true,
        unit: 'currency'
      };
    } else {
      metric = metricData.find(m => m.id === metricId) || 
               standardizedMetrics[metricId] || 
               { id: metricId, title: 'Metric' };
    }

    // Check if we're dealing with a stacked chart
    const isStacked = chartData.datasets.some(ds => ds.stack !== undefined);
    
    if (isStacked && metricId === 'total-revenue') {
      // For stacked bar charts, show all categories in the tooltip
      let tooltipContent = `<strong>${chartData.labels[dataIndex]}</strong>`;
      
      // Process each dataset in the stacked chart
      let hasValidData = false;
      chartData.datasets.forEach(dataset => {
        if (!dataset || !dataset.data || dataIndex >= dataset.data.length) return;
        
        const value = dataset.data[dataIndex];
        if (value > 0) { // Only show non-zero values
          hasValidData = true;
          const formattedValue = metric.unit === 'currency' ? formatCurrency(value) : formatNumber(value);
          
          // Determine color based on dataset
          let color;
          if (dataset.label === 'MRR') {
            color = STRIPE_PURPLE;
          } else if (dataset.label === 'Usage revenue') {
            color = USAGE_BLUE;
          } else if (dataset.label === 'Forecasted usage revenue') {
            color = USAGE_BLUE;
          } else {
            color = dataset.borderColor || '#333';
          }
          
          tooltipContent += `<div style="color: ${color};">${dataset.label}: ${formattedValue}</div>`;
        }
      });
      
      if (!hasValidData) return;
      
      // Add the total if this is a stacked bar chart
      const total = chartData.datasets.reduce((acc, dataset) => {
        if (!dataset || !dataset.data || dataIndex >= dataset.data.length) return acc;
        return acc + (dataset.data[dataIndex] || 0);
      }, 0);
      
      tooltipContent += `<div style="margin-top: 4px; font-weight: 600;">Total: ${formatCurrency(total)}</div>`;
      
      showTooltip(event.clientX, yPosition, tooltipContent, metricId);
    } else {
      // Standard tooltip handling for non-stacked charts
      const currentData = chartData.datasets[0]?.data;
      const previousData = chartData.datasets[1]?.data;
      
      if (!currentData || dataIndex >= currentData.length) return;
      
      const currentValue = currentData[dataIndex];
      if (currentValue === undefined || currentValue === null) return;
      
      const previousValue = previousData && dataIndex < previousData.length ? previousData[dataIndex] : null;
      
      let tooltipContent = `<strong>${chartData.labels[dataIndex]}</strong>`;
      
      if (metric.unit === 'currency' || metric.isCurrency) {
        tooltipContent += `<div class="current-value">Current: ${formatCurrency(currentValue)}</div>`;
      } else if (metric.unit === 'percentage') {
        tooltipContent += `<div class="current-value">Current: ${formatPercentage(currentValue)}</div>`;
      } else {
        tooltipContent += `<div class="current-value">Current: ${formatNumber(currentValue)}</div>`;
      }
      
      if (previousValue !== null && previousValue !== undefined) {
        if (metric.unit === 'currency' || metric.isCurrency) {
          tooltipContent += `<div class="previous-value">Previous: ${formatCurrency(previousValue)}</div>`;
        } else if (metric.unit === 'percentage') {
          tooltipContent += `<div class="previous-value">Previous: ${formatPercentage(previousValue)}</div>`;
        } else {
          tooltipContent += `<div class="previous-value">Previous: ${formatNumber(previousValue)}</div>`;
        }
      }
      
      showTooltip(event.clientX, yPosition, tooltipContent, metricId);
    }
  }, [formatCurrency, formatPercentage, formatNumber, metricData, showTooltip]);

  // Generate chart data for metrics
  const generateMetricChartData = useCallback((metric, period, interval, includePrevious = true) => {
    let labels = [];
    let currentData = [];
    let previousData = [];
    let pointCount = 0;
    
    // Determine number of data points based on period and interval
    switch (period) {
      case 'last7days':
        pointCount = interval === 'daily' ? 7 : 1;
        break;
      case 'last30days':
        pointCount = interval === 'daily' ? 30 : interval === 'weekly' ? 4 : 1;
        break;
      case 'last90days':
        pointCount = interval === 'daily' ? 90 : interval === 'weekly' ? 13 : 3;
        break;
      case 'thisYear':
        pointCount = interval === 'daily' ? 30 : interval === 'weekly' ? 52 : 12;
        break;
      default:
        pointCount = 7;
    }
    
    // Generate labels based on interval
    const today = new Date();
    
    for (let i = pointCount - 1; i >= 0; i--) {
      let date = new Date(today);
      
      if (interval === 'daily') {
        date.setDate(today.getDate() - i);
        labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
      } else if (interval === 'weekly') {
        date.setDate(today.getDate() - (i * 7));
        labels.push(`Week of ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`);
      } else if (interval === 'monthly') {
        date.setMonth(today.getMonth() - i);
        labels.push(date.toLocaleDateString('en-US', { month: 'long' }));
      }
    }

    // Use metric.id as seed for consistent pseudorandom values
    const generateStableRandomValue = (i, metric) => {
      // Create a deterministic seed based on metric id and index
      const seed = metric.id.charCodeAt(0) + (i * 100);
      // Simple pseudorandom generator with seed
      const random = Math.sin(seed) * 10000;
      return Math.abs(random - Math.floor(random));
    };
    
    // Generate trend data based on metric type with stable random values
    if (metric.isCurrency) {
      // Handle currency metrics - general trend with some volatility
      const baseValue = metric.baseCurrencyValue;
      
      // Generate current data with appropriate trend
      currentData = new Array(pointCount).fill(0).map((_, i) => {
        const progress = i / (pointCount - 1); // 0 to 1 based on position in timeline
        const trendFactor = metric.trend === 'up' ? 1 + (progress * 0.05) : 1 - (progress * 0.03);
        const randomFactor = 1 + ((generateStableRandomValue(i, metric) * 0.16) - 0.08);
        return baseValue * trendFactor * randomFactor;
      });
      
      if (includePrevious) {
        // Previous period data - slightly different trend
        const prevTrendMultiplier = metric.trend === 'up' ? 0.92 : 1.05;
        previousData = currentData.map((val, i) => val * prevTrendMultiplier * (1 + ((generateStableRandomValue(i + 50, metric) * 0.1) - 0.05)));
      }
    } else if (metric.id.includes('rate') || metric.unit === 'percentage') {
      // Handle percentage/rate metrics - smaller numbers, less volatility
      const baseValue = metric.baseNumberValue; 
      
      currentData = new Array(pointCount).fill(0).map((_, i) => {
        const progress = i / (pointCount - 1);
        const trendFactor = metric.trend === 'up' ? 1 + (progress * 0.03) : 1 - (progress * 0.02);
        const randomFactor = 1 + ((generateStableRandomValue(i, metric) * 0.1) - 0.05);
        return baseValue * trendFactor * randomFactor;
      });
      
      if (includePrevious) {
        const prevTrendMultiplier = metric.trend === 'up' ? 0.94 : 1.03;
        previousData = currentData.map((val, i) => val * prevTrendMultiplier * (1 + ((generateStableRandomValue(i + 50, metric) * 0.06) - 0.03)));
      }
    } else {
      // Handle count/number metrics
      const baseValue = metric.baseNumberValue;
      
      currentData = new Array(pointCount).fill(0).map((_, i) => {
        const progress = i / (pointCount - 1);
        const trendFactor = metric.trend === 'up' ? 1 + (progress * 0.04) : 1 - (progress * 0.025);
        const randomFactor = 1 + ((generateStableRandomValue(i, metric) * 0.16) - 0.08);
        
        // Round to whole numbers for count metrics
        return Math.round(baseValue * trendFactor * randomFactor);
      });
      
      if (includePrevious) {
        const prevTrendMultiplier = metric.trend === 'up' ? 0.93 : 1.04;
        previousData = currentData.map((val, i) => Math.round(val * prevTrendMultiplier * (1 + ((generateStableRandomValue(i + 50, metric) * 0.1) - 0.05))));
      }
    }
    
    return {
      labels,
      currentData,
      previousData,
      datasets: [
        {
          label: 'Current',
          data: currentData,
          borderColor: STRIPE_PURPLE,
          backgroundColor: 'transparent',
          tension: 0.4,
          pointRadius: 0,
          borderWidth: 2
        },
        ...(includePrevious ? [{
          label: 'Previous',
          data: previousData,
          borderColor: GRAY,
          backgroundColor: 'transparent',
          tension: 0.4,
          pointRadius: 0,
          borderWidth: 1.5,
          borderDash: [5, 5]
        }] : [])
      ]
    };
  }, []);
  
  // Modify the useEffect to generate chart data with purple lines and comparison lines
  useEffect(() => {
    // Use specific metrics as requested
    const mrrGrowthRateMetric = standardizedMetrics['mrr-growth-rate'];
    const subscriberChurnRateMetric = standardizedMetrics['subscriber-churn-rate'];
    const usageRevenueMetric = standardizedMetrics['usage-revenue'];
    
    // Create a stable set of data points with realistic shapes
    const generateStableChartData = (metric) => {
      // Number of data points for the sparkline
      const pointCount = 12;
      const labels = [];
      
      // Create labels (these won't be shown but needed for chart.js)
      for (let i = 0; i < pointCount; i++) {
        labels.push(`P${i+1}`);
      }
      
      // Generate realistic shapes that mimic the example image
      // We'll use different patterns for each metric to simulate real-world data
      let data = [];
      let prevData = [];
      const baseValue = metric.isCurrency ? metric.baseCurrencyValue : metric.baseNumberValue;
      
      if (metric === mrrGrowthRateMetric) {
        // Shape pattern: starts medium, drops, gradual rise with a final spike (like the example)
        const pattern = [1.0, 0.7, 0.5, 0.65, 0.8, 0.9, 0.85, 0.95, 0.9, 1.05, 1.1, 1.4];
        data = pattern.map(factor => baseValue * factor);
        // Previous period data (slightly lower values)
        prevData = pattern.map(factor => baseValue * factor * 0.85);
      } 
      else if (metric === subscriberChurnRateMetric) {
        // Shape pattern: starts low, spike in middle, drop, then gradual increase
        const pattern = [0.8, 0.9, 1.0, 1.2, 1.3, 1.1, 0.9, 0.85, 0.95, 1.0, 1.05, 1.1];
        data = pattern.map(factor => baseValue * factor);
        // Previous period data (slightly higher values for churn - worse performance)
        prevData = pattern.map(factor => baseValue * factor * 1.15);
      }
      else if (metric === usageRevenueMetric) {
        // Shape pattern: zigzag with overall upward trend
        const pattern = [0.85, 1.0, 0.9, 1.05, 0.95, 1.1, 1.0, 1.15, 1.05, 1.2, 1.1, 1.25];
        data = pattern.map(factor => baseValue * factor);
        // Previous period data (slightly lower values)
        prevData = pattern.map(factor => baseValue * factor * 0.8);
      }
      
      return {
        labels,
        datasets: [
          {
            data,
            borderColor: STRIPE_PURPLE, // Use Stripe purple for all sparklines
            backgroundColor: 'transparent',
            tension: 0.2, // Less tension for more pronounced angles like in the example
            pointRadius: 0,
            pointHoverRadius: 0,
            borderWidth: 2
          },
          {
            data: prevData,
            borderColor: GRAY, // Gray for comparison line
            backgroundColor: 'transparent',
            tension: 0.2,
            pointRadius: 0,
            pointHoverRadius: 0,
            borderWidth: 1.5,
            borderDash: [5, 5]
          }
        ]
      };
    };
    
    // Create metrics with stable chart data
    const stableMetrics = [mrrGrowthRateMetric, subscriberChurnRateMetric, usageRevenueMetric].map(metric => {
      const chartData = generateStableChartData(metric);
      
      let displayValue;
      if (metric.isCurrency) {
        displayValue = formatCurrency(metric.baseCurrencyValue);
      } else if (metric.unit === 'percentage') {
        displayValue = formatPercentage(metric.baseNumberValue);
      } else {
        displayValue = formatNumber(metric.baseNumberValue);
      }
      
      const trendSign = metric.trend === 'up' ? '+' : '-';
      const trendDisplay = `${trendSign}${Math.abs(metric.trendValue).toFixed(2)}%`;
      
      return {
        ...metric,
        displayValue,
        trendDisplay,
        chartData
      };
    });
    
    setTrendingMetrics(stableMetrics);
  }, [formatCurrency, formatPercentage, formatNumber]);

  // Use useMemo to create stable metric data for the two-column layout metrics
  const stableNewSubscribersData = useMemo(() => {
    const metric = standardizedMetrics['new-subscribers'];
    const chartData = generateMetricChartData(metric, 'last30days', 'daily', true); // Changed to true to include comparison
    return { metric, chartData };
  }, [generateMetricChartData]);
  
  const stableActiveSubscribersData = useMemo(() => {
    const metric = standardizedMetrics['active-subscribers'];
    const chartData = generateMetricChartData(metric, 'last30days', 'daily', true); // Changed to true to include comparison
    return { metric, chartData };
  }, [generateMetricChartData]);
  
  const stableMrrGrowthData = useMemo(() => {
    const metric = standardizedMetrics['mrr-growth'];
    const chartData = generateMetricChartData(metric, 'last30days', 'daily', true); // Changed to true to include comparison
    return { metric, chartData };
  }, [generateMetricChartData]);
  
  // Create stable stacked bar chart data
  const stableRevenueBarData = useMemo(() => {
    // Generate stable data for the stacked bar chart
    const generateStableBarData = (baseValue) => {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
      // Create stable data points using a deterministic approach
      return months.map((month, i) => {
        // Use month index as seed for stable "random" variation
        const seed = month.charCodeAt(0) + (i * 100);
        const random = Math.abs(Math.sin(seed) * 10000);
        const factor = 0.85 + ((random % 0.3) * 0.3);
        return baseValue * factor;
      });
    };
    
    const mrrValue = 42500;
    const usageValue = 15800;
    
    return {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
      datasets: [
        {
          label: 'MRR',
          data: generateStableBarData(mrrValue),
          backgroundColor: STRIPE_PURPLE,
          borderColor: STRIPE_PURPLE,
          borderWidth: 1,
          barPercentage: 0.6,
          categoryPercentage: 0.8
        },
        {
          label: 'Usage revenue',
          data: generateStableBarData(usageValue),
          backgroundColor: '#AAB7C4',
          borderColor: '#AAB7C4',
          borderWidth: 1,
          barPercentage: 0.6,
          categoryPercentage: 0.8
        }
      ]
    };
  }, []);
  
  // Create a stable total revenue metric to use with renderSimpleMetric
  const stableTotalRevenueData = useMemo(() => {
    // Create a placeholder for total revenue metric
    const totalRevenueMetric = {
      id: 'total-revenue',
      title: 'Total revenue',
      isCurrency: true,
      baseCurrencyValue: 58300, // MRR 42500 + Usage 15800
      unit: 'currency',
      trend: 'up',
      trendValue: 5.2,
    };
    
    // Generate chart data for the metric using a stacked bar chart configuration
    const chartData = {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
      datasets: [
        {
          label: 'MRR',
          data: [38000, 39500, 41000, 40500, 42000, 42500],
          backgroundColor: STRIPE_PURPLE,
          borderColor: STRIPE_PURPLE,
          borderWidth: 1,
          barPercentage: 0.6,
          categoryPercentage: 0.8,
          stack: 'stack1'
        },
        {
          label: 'Usage revenue',
          data: [12000, 13500, 14000, 14500, 15000, 15800],
          backgroundColor: USAGE_BLUE,
          borderColor: USAGE_BLUE,
          borderWidth: 1,
          barPercentage: 0.6,
          categoryPercentage: 0.8,
          stack: 'stack1'
        },
        {
          label: 'Forecasted usage revenue',
          data: [0, 0, 0, 0, 0, 17200],
          backgroundColor: 'white',
          borderColor: USAGE_BLUE,
          borderWidth: 1,
          barPercentage: 0.6,
          categoryPercentage: 0.8,
          stack: 'stack1'
        }
      ]
    };
    
    return { metric: totalRevenueMetric, chartData };
  }, []);
  
  // Update the renderSimpleMetric function to define a component inline
  const renderSimpleMetric = useCallback((memoizedData) => {
    // Define SimpleMetric component inside the render function
    const SimpleMetricComponent = ({ memoizedData }) => {
      const { metric, chartData } = memoizedData;
      
      // Refs for throttling
      const throttleRef = useRef(null);
      
      let displayValue;
      if (metric.isCurrency) {
        displayValue = formatCurrency(metric.baseCurrencyValue);
      } else if (metric.unit === 'percentage') {
        displayValue = formatPercentage(metric.baseNumberValue);
      } else {
        displayValue = formatNumber(metric.baseNumberValue);
      }
      
      const trendSign = metric.trend === 'up' ? '+' : '-';
      const trendDisplay = `${trendSign}${Math.abs(metric.trendValue).toFixed(2)}%`;
      
      // Memoized event handlers
      const optimizedTooltipHandler = useCallback((e) => {
        // Skip if no event or already processing
        if (!e || !e.currentTarget) return;
        if (throttleRef.current) return;
        
        // Set throttle timer with longer delay to prevent flickering
        throttleRef.current = setTimeout(() => {
          throttleRef.current = null;
        }, 100);
        
        handleShowTooltip(e, metric.id, chartData);
      }, [metric.id, chartData]);
      
      const optimizedHideTooltip = useCallback(() => {
        hideTooltip();
      }, []);
      
      return (
        <MetricCard key={metric.id} onClick={() => handleMetricClick(metric)}>
          <ExploreAction className="explore-action">
            Explore
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 17L17 7" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              <path d="M7 7H17V17" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
            </svg>
          </ExploreAction>
          
          <MetricHeader>
            <MetricTitle>{metric.title}</MetricTitle>
            <MetricValueRow>
              <MetricValue>
                {displayValue}
                {metric.trendValue > 0 && (
                  <MetricTrend trend={metric.trend}>
                    {trendDisplay}
                  </MetricTrend>
                )}
              </MetricValue>
            </MetricValueRow>
          </MetricHeader>
          
          <MetricChartContainer 
            onMouseMove={optimizedTooltipHandler}
            onMouseLeave={optimizedHideTooltip}
          >
            <LineChart 
              data={chartData} 
              height={160} 
              showLegend={false}
              unit={metric.unit}
            />
          </MetricChartContainer>
        </MetricCard>
      );
    };
    
    return <SimpleMetricComponent memoizedData={memoizedData} />;
  }, [formatCurrency, formatPercentage, formatNumber, handleShowTooltip, hideTooltip, handleMetricClick]);

  // Create a non-interactive styled card specifically for the Total Revenue chart
  const StaticMetricCard = styled.div`
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: none;
    display: flex;
    flex-direction: column;
    position: relative;
    cursor: default;
  `;

  // Handle tab change and update URL
  const handleTabChange = (tab) => {
    setActiveTab(tab);
    // Update URL with tab parameter without full page reload
    navigate(`/billing/overview?tab=${tab}`, { replace: true });
  };

  // Handle period change from reporting controls
  const handlePeriodChange = (period) => {
    setActivePeriod(period);
    // Update metrics for the new period
    updateMetricsForPeriodChange(period);
  };
  
  // Handle interval change from reporting controls
  const handleIntervalChange = (interval) => {
    setActiveInterval(interval);
    // Update metrics for the new interval
    updateMetricsForIntervalChange(interval);
  };
  
  // Handle comparison change from reporting controls
  const handleComparisonChange = (comparison) => {
    setActiveComparison(comparison);
    // Update metrics for the new comparison
    updateMetricsForComparisonChange(comparison);
  };
  
  // Update metrics when period changes
  const updateMetricsForPeriodChange = (period) => {
    // Implementation depends on how metrics are generated in your app
    // This is a placeholder for the actual implementation
    const updatedMetrics = baseRevenueMetrics.map(metric => {
      // Update metric data for new period
      // ...
      return metric;
    });
    // Update metrics state if necessary
    // setMetrics(updatedMetrics);
  };
  
  // Update metrics when interval changes
  const updateMetricsForIntervalChange = (interval) => {
    // Implementation depends on how metrics are generated in your app
    // This is a placeholder for the actual implementation
    const updatedMetrics = baseRevenueMetrics.map(metric => {
      // Update metric data for new interval
      // ...
      return metric;
    });
    // Update metrics state if necessary
    // setMetrics(updatedMetrics);
  };
  
  // Update metrics when comparison changes
  const updateMetricsForComparisonChange = (comparison) => {
    // Implementation depends on how metrics are generated in your app
    // This is a placeholder for the actual implementation
    const updatedMetrics = baseRevenueMetrics.map(metric => {
      // Update metric data for new comparison
      // ...
      return metric;
    });
    // Update metrics state if necessary
    // setMetrics(updatedMetrics);
  };

  // Render bar chart metric with legend
  const renderBarChartMetricWithLegend = useCallback((chartData) => {
    if (!chartData) return null;
    
    // Extract the metric from the data
    const { metric } = chartData;
    if (!metric) return null;
    
    // Format the value based on its type
    const displayValue = metric.isCurrency 
      ? formatCurrency(metric.baseCurrencyValue)
      : metric.unit === 'percentage'
        ? formatPercentage(metric.baseNumberValue)
        : formatNumber(metric.baseNumberValue);
    
    return (
      <BarChartMetricCard>
        <MetricHeader>
          <div>
            <MetricTitle>{metric.title}</MetricTitle>
            <MetricValue>{displayValue}</MetricValue>
          </div>
        </MetricHeader>
        
        <ChartContainer
          onMouseMove={(e) => handleShowTooltip(e, metric.id, chartData.chartData)}
          onMouseLeave={hideTooltip}
        >
          <BarChart
            data={chartData.chartData}
            height={180}
            options={{
              maintainAspectRatio: false,
              scales: {
                x: {
                  grid: {
                    display: false
                  }
                },
                y: {
                  beginAtZero: true,
                  grid: {
                    borderDash: [3, 3]
                  },
                  ticks: {
                    callback: function(value) {
                      if (metric.isCurrency) {
                        return '$' + (value >= 1000 ? (value / 1000) + 'k' : value);
                      }
                      return value;
                    }
                  }
                }
              },
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  enabled: false
                }
              }
            }}
          />
        </ChartContainer>
        
        <Legend>
          {chartData.chartData.datasets.map((dataset, index) => (
            <LegendItem key={index}>
              <LegendColor style={{ backgroundColor: dataset.backgroundColor || dataset.borderColor }} />
              <LegendLabel>{dataset.label}</LegendLabel>
            </LegendItem>
          ))}
        </Legend>
      </BarChartMetricCard>
    );
  }, [formatCurrency, formatPercentage, formatNumber, handleShowTooltip, hideTooltip]);

  // Simple helper to render a metric with chart
  const renderSimpleMetric = useCallback((data) => {
    if (!data || !data.metric) return null;
    
    const { metric, chartData } = data;
    
    // Format the value based on type
    const displayValue = metric.isCurrency 
      ? formatCurrency(metric.baseCurrencyValue)
      : metric.unit === 'percentage'
        ? formatPercentage(metric.baseNumberValue)
        : formatNumber(metric.baseNumberValue);
    
    return (
      <MetricCard key={metric.id} onClick={() => handleMetricClick(metric)}>
        <MetricHeader>
          <MetricTitle>{metric.title}</MetricTitle>
          <MetricValue>{displayValue}</MetricValue>
        </MetricHeader>
        
        <MetricChartContainer
          onMouseMove={(e) => handleShowTooltip(e, metric.id, chartData)}
          onMouseLeave={hideTooltip}
        >
          <LineChart 
            data={chartData} 
            height={160} 
            showLegend={false}
            unit={metric.unit}
          />
        </MetricChartContainer>
      </MetricCard>
    );
  }, [formatCurrency, formatPercentage, formatNumber, handleMetricClick, handleShowTooltip, hideTooltip]);

  // Render content based on active tab
  const renderTabContent = useCallback(() => {
    switch (activeTab) {
      case 'revenue':
        return (
          <>
            {renderMetricsGrid(metricData)}
            
            {renderReportSection("Report downloads", [
              {
                id: 'mrr-per-subscriber',
                title: "MRR per subscriber per month",
                description: "Includes the MRR for each subscriber at the end of the month."
              },
              {
                id: 'subscription-metrics',
                title: "Subscription metrics per month",
                description: "Includes your MRR roll-forward, subscriber roll-forward, retention, and customer value for each month."
              },
              {
                id: 'customer-mrr-changes',
                title: "Customer MRR changes",
                description: "Includes a log of every MRR change for each customer, including new subscribers, upgrades, downgrades, reactivations, and churn."
              }
            ])}
          </>
        );

      case 'summary':
        return (
          <>
            <div>
              <SectionTitle>Trending</SectionTitle>
              <TrendingGrid>
                {trendingMetrics.map(metric => (
                  <TrendingCard key={metric.id} onClick={() => handleMetricClick(metric)}>
                    <ExploreAction className="explore-action">
                      Explore
                      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M7 17L17 7" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                        <path d="M7 7H17V17" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                      </svg>
                    </ExploreAction>
                    
                    <TrendingTitle>{metric.title}</TrendingTitle>
                    <TrendingContent>
                      <TrendingValueSection>
                        <TrendingValue>{metric.displayValue}</TrendingValue>
                        <TrendingTrend trend={metric.trend}>{metric.trendDisplay}</TrendingTrend>
                      </TrendingValueSection>
                      <SparklineContainer>
                        <LineChart 
                          data={metric.chartData} 
                          height={50} 
                          showLegend={false} 
                          showAxes={false}
                          unit={metric.unit}
                          reducedLabels={true}
                        />
                      </SparklineContainer>
                    </TrendingContent>
                  </TrendingCard>
                ))}
              </TrendingGrid>
            </div>
            
            <div>
              <SectionTitle>Subscriber adoption</SectionTitle>
              <MetricsGrid>
                {renderSimpleMetric(stableNewSubscribersData)}
                <InsightModule />
              </MetricsGrid>
            </div>
            
            <div>
              <SectionTitle>Forecasting revenue</SectionTitle>
              <MetricsGrid>
                {renderBarChartMetricWithLegend(modifiedTotalRevenueData)}
                <ConnectedForecastingInputs />
              </MetricsGrid>
            </div>
            
            <div style={{ marginTop: '32px' }}>
              <SectionTitle>Merchant Distribution</SectionTitle>
              <MerchantSegmentation />
            </div>
          </>
        );

      default:
        return (
          <div style={{ textAlign: 'center', padding: '40px 0' }}>
            <p>Select a tab to view content.</p>
          </div>
        );
    }
  }, [
    activeTab, 
    trendingMetrics, 
    stableNewSubscribersData, 
    stableActiveSubscribersData, 
    stableMrrGrowthData, 
    stableRevenueBarData, 
    stableTotalRevenueData, 
    metricData, 
    renderMetricsGrid, 
    renderReportSection, 
    renderBarChartMetricWithLegend, 
    renderSimpleMetric, 
    generateMetricChartData, 
    formatCurrency, 
    formatPercentage, 
    formatNumber, 
    handleShowTooltip, 
    hideTooltip, 
    handleMetricClick, 
    InsightModule, 
    ConnectedForecastingInputs, 
    MerchantSegmentation, 
    SectionTitle, 
    MetricsGrid, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
    TREND_POSITIVE, 
    TREND_NEGATIVE, 
    USAGE_BLUE, 
    GRAY, 
    STRIPE_PURPLE, 
    STRIPE_PURPLE_LIGHT, 
            />
          )}
        </ChartWrapper>
        
        <ConnectedRevenueComposition />
      </ForecastWrapper>
    </PageContainer>
  );
};

export default BillingOverview;
